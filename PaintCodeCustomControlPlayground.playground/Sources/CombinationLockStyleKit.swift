//
//  CombinationLockStyleKit.swift
//  CombinationLock
//
//  Created by Claudius on 30.08.17.
//  Copyright Â© 2017 Claudius Albat. All rights reserved.
//
//  Generated by PaintCode
//  http://www.paintcodeapp.com
//



import UIKit

public class CombinationLockStyleKit : NSObject {

    //// Drawing Methods

    @objc dynamic public class func drawCombinationLock(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 850, height: 850), resizing: ResizingBehavior = .aspectFit, value: CGFloat = 0) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 850, height: 850), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 850, y: resizedFrame.height / 850)
        let resizedShadowScale: CGFloat = min(resizedFrame.width / 850, resizedFrame.height / 850)


        //// Color Declarations
        let strokeColor = UIColor(red: 0.592, green: 0.592, blue: 0.592, alpha: 1.000)
        let fillColor2 = UIColor(red: 0.847, green: 0.847, blue: 0.847, alpha: 1.000)
        let transparent = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 0.000)

        //// Gradient Declarations
        let gradient6 = CGGradient(colorsSpace: nil, colors: [UIColor.white.cgColor, transparent.cgColor] as CFArray, locations: [0, 1])!

        //// Shadow Declarations
        let shadow5 = NSShadow()
        shadow5.shadowColor = UIColor.black
        shadow5.shadowOffset = CGSize(width: 0, height: 0)
        shadow5.shadowBlurRadius = 19
        let shadow6 = NSShadow()
        shadow6.shadowColor = UIColor.black
        shadow6.shadowOffset = CGSize(width: 0, height: 0)
        shadow6.shadowBlurRadius = 72

        //// Variable Declarations
        let rotation: CGFloat = value * 3.6

        //// Group
        //// CombinationLockBG
        //// Scheibe
        context.saveGState()
        context.beginTransparencyLayer(auxiliaryInfo: nil)


        //// Oval-1
        context.saveGState()
        context.setShadow(offset: CGSize(width: shadow5.shadowOffset.width * resizedShadowScale, height: shadow5.shadowOffset.height * resizedShadowScale), blur: shadow5.shadowBlurRadius * resizedShadowScale, color: (shadow5.shadowColor as! UIColor).cgColor)
        context.beginTransparencyLayer(auxiliaryInfo: nil)


        //// Symbol Drawing
        context.saveGState()
        context.translateBy(x: 425.5, y: 423.82)

        let symbolRect = CGRect(x: -347.5, y: -347, width: 694, height: 694)
        context.saveGState()
        context.clip(to: symbolRect)
        context.translateBy(x: symbolRect.minX, y: symbolRect.minY)
        context.translateBy(x: 350, y: 350)

        CombinationLockStyleKit.drawBackgroundCircle(frame: CGRect(origin: .zero, size: symbolRect.size), resizing: .stretch)
        context.restoreGState()

        context.restoreGState()


        //// Oval Drawing
        let ovalPath = UIBezierPath(ovalIn: CGRect(x: 76, y: 74.82, width: 698, height: 698))
        context.saveGState()
        ovalPath.addClip()
        context.drawRadialGradient(gradient6,
            startCenter: CGPoint(x: 425, y: 423.82), startRadius: 360.73,
            endCenter: CGPoint(x: 425, y: 423.82), endRadius: 333.21,
            options: [.drawsBeforeStartLocation, .drawsAfterEndLocation])
        context.restoreGState()


        context.endTransparencyLayer()
        context.restoreGState()


        //// Rad
        context.saveGState()
        context.setShadow(offset: CGSize(width: shadow6.shadowOffset.width * resizedShadowScale, height: shadow6.shadowOffset.height * resizedShadowScale), blur: shadow6.shadowBlurRadius * resizedShadowScale, color: (shadow6.shadowColor as! UIColor).cgColor)
        context.setBlendMode(.difference)
        context.beginTransparencyLayer(auxiliaryInfo: nil)


        //// Oval 2 Drawing
        let oval2Path = UIBezierPath(ovalIn: CGRect(x: 241, y: 241, width: 366, height: 366))
        UIColor.darkGray.setFill()
        oval2Path.fill()


        context.endTransparencyLayer()
        context.restoreGState()


        context.endTransparencyLayer()
        context.restoreGState()




        //// Triangle
        context.saveGState()
        context.setShadow(offset: CGSize(width: shadow5.shadowOffset.width * resizedShadowScale, height: shadow5.shadowOffset.height * resizedShadowScale), blur: shadow5.shadowBlurRadius * resizedShadowScale, color: (shadow5.shadowColor as! UIColor).cgColor)
        context.beginTransparencyLayer(auxiliaryInfo: nil)


        //// path- Drawing
        let pathPath = UIBezierPath()
        pathPath.move(to: CGPoint(x: 400.66, y: 29))
        pathPath.addLine(to: CGPoint(x: 449.34, y: 29))
        pathPath.addLine(to: CGPoint(x: 425, y: 65.06))
        pathPath.addLine(to: CGPoint(x: 400.66, y: 29))
        pathPath.close()
        pathPath.usesEvenOddFillRule = true
        fillColor2.setFill()
        pathPath.fill()
        strokeColor.setStroke()
        pathPath.lineWidth = 1
        pathPath.miterLimit = 4
        pathPath.stroke()


        context.endTransparencyLayer()
        context.restoreGState()


        //// wheel Drawing
        context.saveGState()
        context.translateBy(x: 425, y: 425)
        context.rotate(by: -rotation * CGFloat.pi/180)

        let wheelRect = CGRect(x: -340, y: -340, width: 680, height: 680)
        context.saveGState()
        context.clip(to: wheelRect)
        context.translateBy(x: wheelRect.minX, y: wheelRect.minY)
        context.translateBy(x: 340, y: 340)

        CombinationLockStyleKit.drawWheelControl(frame: CGRect(origin: .zero, size: wheelRect.size), resizing: .stretch)
        context.restoreGState()

        context.restoreGState()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawWheelControl(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 680, height: 680), resizing: ResizingBehavior = .aspectFit) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 680, height: 680), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 680, y: resizedFrame.height / 680)


        //// Color Declarations
        let gradientColor5 = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)
        let gradientColor6 = UIColor(red: 0.560, green: 0.560, blue: 0.560, alpha: 1.000)

        //// Gradient Declarations
        let gradient = CGGradient(colorsSpace: nil, colors: [gradientColor5.cgColor, gradientColor5.cgColor, gradientColor6.cgColor] as CFArray, locations: [0, 0.88, 1])!

        //// Bezier 4 Drawing
        let bezier4Path = UIBezierPath()
        bezier4Path.move(to: CGPoint(x: 0, y: 195.39))
        bezier4Path.addLine(to: CGPoint(x: -12.56, y: 200))
        bezier4Path.addLine(to: CGPoint(x: -24.44, y: 193.85))
        bezier4Path.addLine(to: CGPoint(x: -37.48, y: 196.85))
        bezier4Path.addLine(to: CGPoint(x: -48.5, y: 189.25))
        bezier4Path.addLine(to: CGPoint(x: -61.8, y: 190.59))
        bezier4Path.addLine(to: CGPoint(x: -71.79, y: 181.67))
        bezier4Path.addLine(to: CGPoint(x: -85.16, y: 181.32))
        bezier4Path.addLine(to: CGPoint(x: -93.94, y: 171.22))
        bezier4Path.addLine(to: CGPoint(x: -107.17, y: 169.2))
        bezier4Path.addLine(to: CGPoint(x: -114.62, y: 158.07))
        bezier4Path.addLine(to: CGPoint(x: -127.48, y: 154.41))
        bezier4Path.addLine(to: CGPoint(x: -133.49, y: 142.43))
        bezier4Path.addLine(to: CGPoint(x: -145.79, y: 137.18))
        bezier4Path.addLine(to: CGPoint(x: -150.25, y: 124.54))
        bezier4Path.addLine(to: CGPoint(x: -161.8, y: 117.79))
        bezier4Path.addLine(to: CGPoint(x: -164.65, y: 104.69))
        bezier4Path.addLine(to: CGPoint(x: -175.26, y: 96.54))
        bezier4Path.addLine(to: CGPoint(x: -176.44, y: 83.19))
        bezier4Path.addLine(to: CGPoint(x: -185.96, y: 73.77))
        bezier4Path.addLine(to: CGPoint(x: -185.46, y: 60.38))
        bezier4Path.addLine(to: CGPoint(x: -193.72, y: 49.84))
        bezier4Path.addLine(to: CGPoint(x: -191.55, y: 36.61))
        bezier4Path.addLine(to: CGPoint(x: -198.42, y: 25.12))
        bezier4Path.addLine(to: CGPoint(x: -194.62, y: 12.27))
        bezier4Path.addLine(to: CGPoint(x: -200, y: -0))
        bezier4Path.addLine(to: CGPoint(x: -194.62, y: -12.27))
        bezier4Path.addLine(to: CGPoint(x: -198.42, y: -25.12))
        bezier4Path.addLine(to: CGPoint(x: -191.55, y: -36.61))
        bezier4Path.addLine(to: CGPoint(x: -193.72, y: -49.84))
        bezier4Path.addLine(to: CGPoint(x: -185.46, y: -60.38))
        bezier4Path.addLine(to: CGPoint(x: -185.96, y: -73.77))
        bezier4Path.addLine(to: CGPoint(x: -176.44, y: -83.19))
        bezier4Path.addLine(to: CGPoint(x: -175.26, y: -96.54))
        bezier4Path.addLine(to: CGPoint(x: -164.65, y: -104.69))
        bezier4Path.addLine(to: CGPoint(x: -161.8, y: -117.79))
        bezier4Path.addLine(to: CGPoint(x: -150.25, y: -124.54))
        bezier4Path.addLine(to: CGPoint(x: -145.79, y: -137.18))
        bezier4Path.addLine(to: CGPoint(x: -133.49, y: -142.43))
        bezier4Path.addLine(to: CGPoint(x: -127.48, y: -154.41))
        bezier4Path.addLine(to: CGPoint(x: -114.62, y: -158.07))
        bezier4Path.addLine(to: CGPoint(x: -107.17, y: -169.2))
        bezier4Path.addLine(to: CGPoint(x: -93.94, y: -171.22))
        bezier4Path.addLine(to: CGPoint(x: -85.16, y: -181.32))
        bezier4Path.addLine(to: CGPoint(x: -71.79, y: -181.67))
        bezier4Path.addLine(to: CGPoint(x: -61.8, y: -190.59))
        bezier4Path.addLine(to: CGPoint(x: -48.5, y: -189.25))
        bezier4Path.addLine(to: CGPoint(x: -37.48, y: -196.85))
        bezier4Path.addLine(to: CGPoint(x: -24.44, y: -193.85))
        bezier4Path.addLine(to: CGPoint(x: -12.56, y: -200))
        bezier4Path.addLine(to: CGPoint(x: 0, y: -195.39))
        bezier4Path.addLine(to: CGPoint(x: 12.56, y: -200))
        bezier4Path.addLine(to: CGPoint(x: 24.44, y: -193.85))
        bezier4Path.addLine(to: CGPoint(x: 37.48, y: -196.85))
        bezier4Path.addLine(to: CGPoint(x: 48.5, y: -189.25))
        bezier4Path.addLine(to: CGPoint(x: 61.8, y: -190.59))
        bezier4Path.addLine(to: CGPoint(x: 71.79, y: -181.67))
        bezier4Path.addLine(to: CGPoint(x: 85.16, y: -181.32))
        bezier4Path.addLine(to: CGPoint(x: 93.94, y: -171.22))
        bezier4Path.addLine(to: CGPoint(x: 107.17, y: -169.2))
        bezier4Path.addLine(to: CGPoint(x: 114.62, y: -158.07))
        bezier4Path.addLine(to: CGPoint(x: 127.48, y: -154.41))
        bezier4Path.addLine(to: CGPoint(x: 133.49, y: -142.43))
        bezier4Path.addLine(to: CGPoint(x: 145.79, y: -137.18))
        bezier4Path.addLine(to: CGPoint(x: 150.25, y: -124.54))
        bezier4Path.addLine(to: CGPoint(x: 161.8, y: -117.79))
        bezier4Path.addLine(to: CGPoint(x: 164.65, y: -104.69))
        bezier4Path.addLine(to: CGPoint(x: 175.26, y: -96.54))
        bezier4Path.addLine(to: CGPoint(x: 176.44, y: -83.19))
        bezier4Path.addLine(to: CGPoint(x: 185.96, y: -73.77))
        bezier4Path.addLine(to: CGPoint(x: 185.46, y: -60.38))
        bezier4Path.addLine(to: CGPoint(x: 193.72, y: -49.84))
        bezier4Path.addLine(to: CGPoint(x: 191.55, y: -36.61))
        bezier4Path.addLine(to: CGPoint(x: 198.42, y: -25.12))
        bezier4Path.addLine(to: CGPoint(x: 194.62, y: -12.27))
        bezier4Path.addLine(to: CGPoint(x: 200, y: -0))
        bezier4Path.addLine(to: CGPoint(x: 194.62, y: 12.27))
        bezier4Path.addLine(to: CGPoint(x: 198.42, y: 25.12))
        bezier4Path.addLine(to: CGPoint(x: 191.55, y: 36.61))
        bezier4Path.addLine(to: CGPoint(x: 193.72, y: 49.84))
        bezier4Path.addLine(to: CGPoint(x: 185.46, y: 60.38))
        bezier4Path.addLine(to: CGPoint(x: 185.96, y: 73.77))
        bezier4Path.addLine(to: CGPoint(x: 176.44, y: 83.19))
        bezier4Path.addLine(to: CGPoint(x: 175.26, y: 96.54))
        bezier4Path.addLine(to: CGPoint(x: 164.65, y: 104.69))
        bezier4Path.addLine(to: CGPoint(x: 161.8, y: 117.79))
        bezier4Path.addLine(to: CGPoint(x: 150.25, y: 124.54))
        bezier4Path.addLine(to: CGPoint(x: 145.79, y: 137.18))
        bezier4Path.addLine(to: CGPoint(x: 133.49, y: 142.43))
        bezier4Path.addLine(to: CGPoint(x: 127.48, y: 154.41))
        bezier4Path.addLine(to: CGPoint(x: 114.62, y: 158.07))
        bezier4Path.addLine(to: CGPoint(x: 107.17, y: 169.2))
        bezier4Path.addLine(to: CGPoint(x: 93.94, y: 171.22))
        bezier4Path.addLine(to: CGPoint(x: 85.16, y: 181.32))
        bezier4Path.addLine(to: CGPoint(x: 71.79, y: 181.67))
        bezier4Path.addLine(to: CGPoint(x: 61.8, y: 190.59))
        bezier4Path.addLine(to: CGPoint(x: 48.5, y: 189.25))
        bezier4Path.addLine(to: CGPoint(x: 37.48, y: 196.85))
        bezier4Path.addLine(to: CGPoint(x: 24.44, y: 193.85))
        bezier4Path.addLine(to: CGPoint(x: 12.56, y: 200))
        bezier4Path.addLine(to: CGPoint(x: 0, y: 195.39))
        bezier4Path.close()
        bezier4Path.move(to: CGPoint(x: -0.89, y: 182.62))
        bezier4Path.addCurve(to: CGPoint(x: 182.26, y: -0.89), controlPoint1: CGPoint(x: 100.26, y: 182.62), controlPoint2: CGPoint(x: 182.26, y: 100.46))
        bezier4Path.addCurve(to: CGPoint(x: -0.89, y: -184.4), controlPoint1: CGPoint(x: 182.26, y: -102.24), controlPoint2: CGPoint(x: 100.26, y: -184.4))
        bezier4Path.addCurve(to: CGPoint(x: -184.04, y: -0.89), controlPoint1: CGPoint(x: -102.04, y: -184.4), controlPoint2: CGPoint(x: -184.04, y: -102.24))
        bezier4Path.addCurve(to: CGPoint(x: -0.89, y: 182.62), controlPoint1: CGPoint(x: -184.04, y: 100.46), controlPoint2: CGPoint(x: -102.04, y: 182.62))
        bezier4Path.close()
        bezier4Path.usesEvenOddFillRule = true
        context.saveGState()
        bezier4Path.addClip()
        context.drawRadialGradient(gradient,
            startCenter: CGPoint(x: 0, y: 0), startRadius: 0,
            endCenter: CGPoint(x: 0, y: 0), endRadius: 212.68,
            options: [.drawsBeforeStartLocation, .drawsAfterEndLocation])
        context.restoreGState()


        //// Symbol Drawing
        context.saveGState()

        let symbolRect = CGRect(x: -340, y: -340, width: 680, height: 340)
        context.saveGState()
        context.clip(to: symbolRect)
        context.translateBy(x: symbolRect.minX, y: symbolRect.minY)
        context.translateBy(x: 340, y: 340)

        CombinationLockStyleKit.drawLinesPart(frame: CGRect(origin: .zero, size: symbolRect.size), resizing: .stretch, count: "0")
        context.restoreGState()

        context.restoreGState()


        //// Symbol 2 Drawing
        context.saveGState()
        context.rotate(by: 36 * CGFloat.pi/180)

        let symbol2Rect = CGRect(x: -340, y: -340, width: 680, height: 340)
        context.saveGState()
        context.clip(to: symbol2Rect)
        context.translateBy(x: symbol2Rect.minX, y: symbol2Rect.minY)
        context.translateBy(x: 340, y: 340)

        CombinationLockStyleKit.drawLinesPart(frame: CGRect(origin: .zero, size: symbol2Rect.size), resizing: .stretch, count: "10")
        context.restoreGState()

        context.restoreGState()


        //// Symbol 3 Drawing
        context.saveGState()
        context.translateBy(x: 0.07, y: -0.36)
        context.rotate(by: 72 * CGFloat.pi/180)

        let symbol3Rect = CGRect(x: -340, y: -340, width: 680, height: 340)
        context.saveGState()
        context.clip(to: symbol3Rect)
        context.translateBy(x: symbol3Rect.minX, y: symbol3Rect.minY)
        context.translateBy(x: 340, y: 340)

        CombinationLockStyleKit.drawLinesPart(frame: CGRect(origin: .zero, size: symbol3Rect.size), resizing: .stretch, count: "20")
        context.restoreGState()

        context.restoreGState()


        //// Symbol 4 Drawing
        context.saveGState()
        context.rotate(by: 108 * CGFloat.pi/180)

        let symbol4Rect = CGRect(x: -340, y: -340, width: 680, height: 340)
        context.saveGState()
        context.clip(to: symbol4Rect)
        context.translateBy(x: symbol4Rect.minX, y: symbol4Rect.minY)
        context.translateBy(x: 340, y: 340)

        CombinationLockStyleKit.drawLinesPart(frame: CGRect(origin: .zero, size: symbol4Rect.size), resizing: .stretch, count: "30")
        context.restoreGState()

        context.restoreGState()


        //// Symbol 5 Drawing
        context.saveGState()
        context.rotate(by: 144 * CGFloat.pi/180)

        let symbol5Rect = CGRect(x: -340, y: -340, width: 680, height: 340)
        context.saveGState()
        context.clip(to: symbol5Rect)
        context.translateBy(x: symbol5Rect.minX, y: symbol5Rect.minY)
        context.translateBy(x: 340, y: 340)

        CombinationLockStyleKit.drawLinesPart(frame: CGRect(origin: .zero, size: symbol5Rect.size), resizing: .stretch, count: "40")
        context.restoreGState()

        context.restoreGState()


        //// Symbol 6 Drawing
        context.saveGState()
        context.rotate(by: 180 * CGFloat.pi/180)

        let symbol6Rect = CGRect(x: -340, y: -340, width: 680, height: 340)
        context.saveGState()
        context.clip(to: symbol6Rect)
        context.translateBy(x: symbol6Rect.minX, y: symbol6Rect.minY)
        context.translateBy(x: 340, y: 340)

        CombinationLockStyleKit.drawLinesPart(frame: CGRect(origin: .zero, size: symbol6Rect.size), resizing: .stretch, count: "50")
        context.restoreGState()

        context.restoreGState()


        //// Symbol 7 Drawing
        context.saveGState()
        context.rotate(by: -144 * CGFloat.pi/180)

        let symbol7Rect = CGRect(x: -340, y: -340, width: 680, height: 340)
        context.saveGState()
        context.clip(to: symbol7Rect)
        context.translateBy(x: symbol7Rect.minX, y: symbol7Rect.minY)
        context.translateBy(x: 340, y: 340)

        CombinationLockStyleKit.drawLinesPart(frame: CGRect(origin: .zero, size: symbol7Rect.size), resizing: .stretch, count: "60")
        context.restoreGState()

        context.restoreGState()


        //// Symbol 8 Drawing
        context.saveGState()
        context.rotate(by: -108 * CGFloat.pi/180)

        let symbol8Rect = CGRect(x: -340, y: -340, width: 680, height: 340)
        context.saveGState()
        context.clip(to: symbol8Rect)
        context.translateBy(x: symbol8Rect.minX, y: symbol8Rect.minY)
        context.translateBy(x: 340, y: 340)

        CombinationLockStyleKit.drawLinesPart(frame: CGRect(origin: .zero, size: symbol8Rect.size), resizing: .stretch, count: "70")
        context.restoreGState()

        context.restoreGState()


        //// Symbol 9 Drawing
        context.saveGState()
        context.rotate(by: -72 * CGFloat.pi/180)

        let symbol9Rect = CGRect(x: -340, y: -340, width: 680, height: 340)
        context.saveGState()
        context.clip(to: symbol9Rect)
        context.translateBy(x: symbol9Rect.minX, y: symbol9Rect.minY)
        context.translateBy(x: 340, y: 340)

        CombinationLockStyleKit.drawLinesPart(frame: CGRect(origin: .zero, size: symbol9Rect.size), resizing: .stretch, count: "80")
        context.restoreGState()

        context.restoreGState()


        //// Symbol 10 Drawing
        context.saveGState()
        context.rotate(by: -36 * CGFloat.pi/180)

        let symbol10Rect = CGRect(x: -340, y: -340, width: 680, height: 340)
        context.saveGState()
        context.clip(to: symbol10Rect)
        context.translateBy(x: symbol10Rect.minX, y: symbol10Rect.minY)
        context.translateBy(x: 340, y: 340)

        CombinationLockStyleKit.drawLinesPart(frame: CGRect(origin: .zero, size: symbol10Rect.size), resizing: .stretch, count: "90")
        context.restoreGState()

        context.restoreGState()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawBackgroundPie(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 700, height: 700), resizing: ResizingBehavior = .aspectFit) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 700, height: 700), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 700, y: resizedFrame.height / 700)



        //// Gradient Declarations
        let tileColor = CGGradient(colorsSpace: nil, colors: [UIColor.darkGray.cgColor, UIColor.white.cgColor] as CFArray, locations: [0, 1])!

        //// Oval Drawing
        let ovalRect = CGRect(x: -350, y: -350, width: 700, height: 700)
        let ovalPath = UIBezierPath()
        ovalPath.addArc(withCenter: CGPoint(x: ovalRect.midX, y: ovalRect.midY), radius: ovalRect.width / 2, startAngle: -91 * CGFloat.pi/180, endAngle: -29 * CGFloat.pi/180, clockwise: true)
        ovalPath.addLine(to: CGPoint(x: ovalRect.midX, y: ovalRect.midY))
        ovalPath.close()

        context.saveGState()
        ovalPath.addClip()
        context.drawLinearGradient(tileColor,
            start: CGPoint(x: 0, y: -350),
            end: CGPoint(x: 173.62, y: -97.65),
            options: [.drawsBeforeStartLocation, .drawsAfterEndLocation])
        context.restoreGState()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawBackgroundCircle(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 700, height: 700), resizing: ResizingBehavior = .aspectFit) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 700, height: 700), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 700, y: resizedFrame.height / 700)


        //// Symbol Drawing
        context.saveGState()

        let symbolRect = CGRect(x: -350, y: -350, width: 700, height: 700)
        context.saveGState()
        context.clip(to: symbolRect)
        context.translateBy(x: symbolRect.minX, y: symbolRect.minY)
        context.translateBy(x: 350, y: 350)

        CombinationLockStyleKit.drawBackgroundPie(frame: CGRect(origin: .zero, size: symbolRect.size), resizing: .stretch)
        context.restoreGState()

        context.restoreGState()


        //// Symbol 2 Drawing
        context.saveGState()
        context.rotate(by: 120 * CGFloat.pi/180)
        context.scaleBy(x: -1, y: 1)

        let symbol2Rect = CGRect(x: -350, y: -350, width: 700, height: 700)
        context.saveGState()
        context.clip(to: symbol2Rect)
        context.translateBy(x: symbol2Rect.minX, y: symbol2Rect.minY)
        context.translateBy(x: 350, y: 350)

        CombinationLockStyleKit.drawBackgroundPie(frame: CGRect(origin: .zero, size: symbol2Rect.size), resizing: .stretch)
        context.restoreGState()

        context.restoreGState()


        //// Symbol 3 Drawing
        context.saveGState()
        context.rotate(by: -240 * CGFloat.pi/180)

        let symbol3Rect = CGRect(x: -350, y: -350, width: 700, height: 700)
        context.saveGState()
        context.clip(to: symbol3Rect)
        context.translateBy(x: symbol3Rect.minX, y: symbol3Rect.minY)
        context.translateBy(x: 350, y: 350)

        CombinationLockStyleKit.drawBackgroundPie(frame: CGRect(origin: .zero, size: symbol3Rect.size), resizing: .stretch)
        context.restoreGState()

        context.restoreGState()


        //// Symbol 4 Drawing
        context.saveGState()
        context.rotate(by: -120 * CGFloat.pi/180)
        context.scaleBy(x: -1, y: 1)

        let symbol4Rect = CGRect(x: -350, y: -350, width: 700, height: 700)
        context.saveGState()
        context.clip(to: symbol4Rect)
        context.translateBy(x: symbol4Rect.minX, y: symbol4Rect.minY)
        context.translateBy(x: 350, y: 350)

        CombinationLockStyleKit.drawBackgroundPie(frame: CGRect(origin: .zero, size: symbol4Rect.size), resizing: .stretch)
        context.restoreGState()

        context.restoreGState()


        //// Symbol 5 Drawing
        context.saveGState()
        context.rotate(by: -480 * CGFloat.pi/180)

        let symbol5Rect = CGRect(x: -350, y: -350, width: 700, height: 700)
        context.saveGState()
        context.clip(to: symbol5Rect)
        context.translateBy(x: symbol5Rect.minX, y: symbol5Rect.minY)
        context.translateBy(x: 350, y: 350)

        CombinationLockStyleKit.drawBackgroundPie(frame: CGRect(origin: .zero, size: symbol5Rect.size), resizing: .stretch)
        context.restoreGState()

        context.restoreGState()


        //// Symbol 6 Drawing
        context.saveGState()
        context.rotate(by: -360 * CGFloat.pi/180)
        context.scaleBy(x: -1, y: 1)

        let symbol6Rect = CGRect(x: -350, y: -350, width: 700, height: 700)
        context.saveGState()
        context.clip(to: symbol6Rect)
        context.translateBy(x: symbol6Rect.minX, y: symbol6Rect.minY)
        context.translateBy(x: 350, y: 350)

        CombinationLockStyleKit.drawBackgroundPie(frame: CGRect(origin: .zero, size: symbol6Rect.size), resizing: .stretch)
        context.restoreGState()

        context.restoreGState()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawLineBig(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 340, height: 340), resizing: ResizingBehavior = .aspectFit) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 340, height: 340), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 340, y: resizedFrame.height / 340)


        //// Rectangle Drawing
        let rectanglePath = UIBezierPath(rect: CGRect(x: -1, y: 280, width: 2, height: 60))
        UIColor.black.setFill()
        rectanglePath.fill()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawLinesPart(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 680, height: 340), resizing: ResizingBehavior = .aspectFit, count: String = "0") {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 680, height: 340), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 680, y: resizedFrame.height / 340)


        //// Color Declarations
        let textForeground = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 1.000)

        //// Symbol Drawing
        let symbolRect = CGRect(x: -170, y: -340, width: 340, height: 340)
        context.saveGState()
        context.clip(to: symbolRect)
        context.translateBy(x: symbolRect.minX, y: symbolRect.minY)
        context.translateBy(x: 0, y: symbolRect.height)
        context.scaleBy(x: 1, y: -1)
        context.translateBy(x: 170, y: 0)

        CombinationLockStyleKit.drawLineBig(frame: CGRect(origin: .zero, size: symbolRect.size), resizing: .stretch)
        context.restoreGState()


        //// Symbol 2 Drawing
        context.saveGState()
        context.rotate(by: 3.6 * CGFloat.pi/180)

        let symbol2Rect = CGRect(x: -170, y: -340, width: 340, height: 340)
        context.saveGState()
        context.clip(to: symbol2Rect)
        context.translateBy(x: symbol2Rect.minX, y: symbol2Rect.minY)
        context.translateBy(x: 0, y: symbol2Rect.height)
        context.scaleBy(x: 1, y: -1)
        context.translateBy(x: 170, y: 0)

        CombinationLockStyleKit.drawLineSmall(frame: CGRect(origin: .zero, size: symbol2Rect.size), resizing: .stretch)
        context.restoreGState()

        context.restoreGState()


        //// Symbol 3 Drawing
        context.saveGState()
        context.rotate(by: 7.2 * CGFloat.pi/180)

        let symbol3Rect = CGRect(x: -170, y: -340, width: 340, height: 340)
        context.saveGState()
        context.clip(to: symbol3Rect)
        context.translateBy(x: symbol3Rect.minX, y: symbol3Rect.minY)
        context.translateBy(x: 0, y: symbol3Rect.height)
        context.scaleBy(x: 1, y: -1)
        context.translateBy(x: 170, y: 0)

        CombinationLockStyleKit.drawLineSmall(frame: CGRect(origin: .zero, size: symbol3Rect.size), resizing: .stretch)
        context.restoreGState()

        context.restoreGState()


        //// Symbol 4 Drawing
        context.saveGState()
        context.rotate(by: 10.8 * CGFloat.pi/180)

        let symbol4Rect = CGRect(x: -170, y: -340, width: 340, height: 340)
        context.saveGState()
        context.clip(to: symbol4Rect)
        context.translateBy(x: symbol4Rect.minX, y: symbol4Rect.minY)
        context.translateBy(x: 0, y: symbol4Rect.height)
        context.scaleBy(x: 1, y: -1)
        context.translateBy(x: 170, y: 0)

        CombinationLockStyleKit.drawLineSmall(frame: CGRect(origin: .zero, size: symbol4Rect.size), resizing: .stretch)
        context.restoreGState()

        context.restoreGState()


        //// Symbol 5 Drawing
        context.saveGState()
        context.rotate(by: 14.4 * CGFloat.pi/180)

        let symbol5Rect = CGRect(x: -170, y: -340, width: 340, height: 340)
        context.saveGState()
        context.clip(to: symbol5Rect)
        context.translateBy(x: symbol5Rect.minX, y: symbol5Rect.minY)
        context.translateBy(x: 0, y: symbol5Rect.height)
        context.scaleBy(x: 1, y: -1)
        context.translateBy(x: 170, y: 0)

        CombinationLockStyleKit.drawLineSmall(frame: CGRect(origin: .zero, size: symbol5Rect.size), resizing: .stretch)
        context.restoreGState()

        context.restoreGState()


        //// Symbol 6 Drawing
        context.saveGState()
        context.rotate(by: 18 * CGFloat.pi/180)

        let symbol6Rect = CGRect(x: -170, y: -340, width: 340, height: 340)
        context.saveGState()
        context.clip(to: symbol6Rect)
        context.translateBy(x: symbol6Rect.minX, y: symbol6Rect.minY)
        context.translateBy(x: 0, y: symbol6Rect.height)
        context.scaleBy(x: 1, y: -1)
        context.translateBy(x: 170, y: 0)

        CombinationLockStyleKit.drawLineMid(frame: CGRect(origin: .zero, size: symbol6Rect.size), resizing: .stretch)
        context.restoreGState()

        context.restoreGState()


        //// Symbol 7 Drawing
        context.saveGState()
        context.rotate(by: 21.6 * CGFloat.pi/180)

        let symbol7Rect = CGRect(x: -170, y: -340, width: 340, height: 340)
        context.saveGState()
        context.clip(to: symbol7Rect)
        context.translateBy(x: symbol7Rect.minX, y: symbol7Rect.minY)
        context.translateBy(x: 0, y: symbol7Rect.height)
        context.scaleBy(x: 1, y: -1)
        context.translateBy(x: 170, y: 0)

        CombinationLockStyleKit.drawLineSmall(frame: CGRect(origin: .zero, size: symbol7Rect.size), resizing: .stretch)
        context.restoreGState()

        context.restoreGState()


        //// Symbol 8 Drawing
        context.saveGState()
        context.rotate(by: 25.2 * CGFloat.pi/180)

        let symbol8Rect = CGRect(x: -170, y: -340, width: 340, height: 340)
        context.saveGState()
        context.clip(to: symbol8Rect)
        context.translateBy(x: symbol8Rect.minX, y: symbol8Rect.minY)
        context.translateBy(x: 0, y: symbol8Rect.height)
        context.scaleBy(x: 1, y: -1)
        context.translateBy(x: 170, y: 0)

        CombinationLockStyleKit.drawLineSmall(frame: CGRect(origin: .zero, size: symbol8Rect.size), resizing: .stretch)
        context.restoreGState()

        context.restoreGState()


        //// Symbol 9 Drawing
        context.saveGState()
        context.rotate(by: 28.8 * CGFloat.pi/180)

        let symbol9Rect = CGRect(x: -170, y: -340, width: 340, height: 340)
        context.saveGState()
        context.clip(to: symbol9Rect)
        context.translateBy(x: symbol9Rect.minX, y: symbol9Rect.minY)
        context.translateBy(x: 0, y: symbol9Rect.height)
        context.scaleBy(x: 1, y: -1)
        context.translateBy(x: 170, y: 0)

        CombinationLockStyleKit.drawLineSmall(frame: CGRect(origin: .zero, size: symbol9Rect.size), resizing: .stretch)
        context.restoreGState()

        context.restoreGState()


        //// Symbol 10 Drawing
        context.saveGState()
        context.rotate(by: 32.4 * CGFloat.pi/180)

        let symbol10Rect = CGRect(x: -170, y: -340, width: 340, height: 340)
        context.saveGState()
        context.clip(to: symbol10Rect)
        context.translateBy(x: symbol10Rect.minX, y: symbol10Rect.minY)
        context.translateBy(x: 0, y: symbol10Rect.height)
        context.scaleBy(x: 1, y: -1)
        context.translateBy(x: 170, y: 0)

        CombinationLockStyleKit.drawLineSmall(frame: CGRect(origin: .zero, size: symbol10Rect.size), resizing: .stretch)
        context.restoreGState()

        context.restoreGState()


        //// Label Drawing
        let labelRect = CGRect(x: -25, y: -264, width: 50, height: 46)
        let labelStyle = NSMutableParagraphStyle()
        labelStyle.alignment = .center
        let labelFontAttributes = [
            .font: UIFont(name: "HelveticaNeue-Light", size: 30)!,
            .foregroundColor: textForeground,
            .paragraphStyle: labelStyle,
        ] as [NSAttributedStringKey: Any]

        let labelTextHeight: CGFloat = count.boundingRect(with: CGSize(width: labelRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: labelFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: labelRect)
        count.draw(in: CGRect(x: labelRect.minX, y: labelRect.minY + (labelRect.height - labelTextHeight) / 2, width: labelRect.width, height: labelTextHeight), withAttributes: labelFontAttributes)
        context.restoreGState()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawLineMid(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 340, height: 340), resizing: ResizingBehavior = .aspectFit) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 340, height: 340), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 340, y: resizedFrame.height / 340)


        //// Rectangle Drawing
        let rectanglePath = UIBezierPath(rect: CGRect(x: -1, y: 300, width: 2, height: 40))
        UIColor.black.setFill()
        rectanglePath.fill()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawLineSmall(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 340, height: 340), resizing: ResizingBehavior = .aspectFit) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 340, height: 340), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 340, y: resizedFrame.height / 340)


        //// Rectangle Drawing
        let rectanglePath = UIBezierPath(rect: CGRect(x: -1, y: 320, width: 2, height: 20))
        UIColor.black.setFill()
        rectanglePath.fill()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawCombinationLockView(frame: CGRect = CGRect(x: 0, y: 0, width: 1200, height: 1200), size: CGFloat = 800) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!


        //// Variable Declarations
        let _offset: CGFloat = -size / 2.0

        //// Symbol 2 Drawing
        let symbol2Rect = CGRect(x: frame.minX, y: frame.minY, width: frame.width, height: frame.height)
        context.saveGState()
        context.clip(to: symbol2Rect)
        context.translateBy(x: symbol2Rect.minX, y: symbol2Rect.minY)

        CombinationLockStyleKit.drawBackground(frame: CGRect(origin: .zero, size: symbol2Rect.size), resizing: .stretch)
        context.restoreGState()


        //// Symbol Drawing
        context.saveGState()
        context.translateBy(x: frame.minX + 0.50000 * frame.width, y: frame.minY + 0.50000 * frame.height)

        let symbolRect = CGRect(x: _offset, y: _offset, width: size, height: size)
        context.saveGState()
        context.clip(to: symbolRect)
        context.translateBy(x: symbolRect.minX, y: symbolRect.minY)

        CombinationLockStyleKit.drawCombinationLock(frame: CGRect(origin: .zero, size: symbolRect.size), resizing: .stretch, value: 0)
        context.restoreGState()

        context.restoreGState()
    }

    @objc dynamic public class func drawBackground(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 1024, height: 1024), resizing: ResizingBehavior = .aspectFit) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 1024, height: 1024), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 1024, y: resizedFrame.height / 1024)


        //// Color Declarations
        let gradientColor = UIColor(red: 0.973, green: 0.973, blue: 0.973, alpha: 0.500)
        let gradientColor2 = UIColor(red: 0.573, green: 0.573, blue: 0.573, alpha: 0.500)

        //// Gradient Declarations
        let linearGradient3 = CGGradient(colorsSpace: nil, colors: [gradientColor2.cgColor, gradientColor2.cgColor, gradientColor.cgColor, gradientColor2.cgColor, gradientColor2.cgColor] as CFArray, locations: [0, 0.23, 0.5, 0.79, 1])!

        //// Hintergrund Drawing
        let hintergrundPath = UIBezierPath(rect: CGRect(x: 0, y: 0, width: 1024, height: 1024))
        context.saveGState()
        hintergrundPath.addClip()
        context.drawLinearGradient(linearGradient3,
            start: CGPoint(x: 2.64, y: 509.44),
            end: CGPoint(x: 1036.88, y: 509.44),
            options: [.drawsBeforeStartLocation, .drawsAfterEndLocation])
        context.restoreGState()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawPreview(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 1284, height: 1342), resizing: ResizingBehavior = .aspectFit) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 1284, height: 1342), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 1284, y: resizedFrame.height / 1342)


        //// Symbol Drawing
        let symbolRect = CGRect(x: 0, y: 0, width: 1284, height: 1342)
        context.saveGState()
        context.clip(to: symbolRect)
        context.translateBy(x: symbolRect.minX, y: symbolRect.minY)

        CombinationLockStyleKit.drawCombinationLockView(frame: CGRect(x: 0, y: 0, width: symbolRect.width, height: symbolRect.height), size: 800)
        context.restoreGState()
        
        context.restoreGState()

    }




    @objc(CombinationLockStyleKitResizingBehavior)
    public enum ResizingBehavior: Int {
        case aspectFit /// The content is proportionally resized to fit into the target rectangle.
        case aspectFill /// The content is proportionally resized to completely fill the target rectangle.
        case stretch /// The content is stretched to match the entire target rectangle.
        case center /// The content is centered in the target rectangle, but it is NOT resized.

        public func apply(rect: CGRect, target: CGRect) -> CGRect {
            if rect == target || target == CGRect.zero {
                return rect
            }

            var scales = CGSize.zero
            scales.width = abs(target.width / rect.width)
            scales.height = abs(target.height / rect.height)

            switch self {
                case .aspectFit:
                    scales.width = min(scales.width, scales.height)
                    scales.height = scales.width
                case .aspectFill:
                    scales.width = max(scales.width, scales.height)
                    scales.height = scales.width
                case .stretch:
                    break
                case .center:
                    scales.width = 1
                    scales.height = 1
            }

            var result = rect.standardized
            result.size.width *= scales.width
            result.size.height *= scales.height
            result.origin.x = target.minX + (target.width - result.width) / 2
            result.origin.y = target.minY + (target.height - result.height) / 2
            return result
        }
    }
}
